using System.Net;
using System.Text.Json;
using Azure.Core;
using Cabazure.Client.SourceGenerator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Primitives;

namespace Cabazure.Client.Tests;

public static class TestHelper
{
    private const string GlobalUsings = """
        // <auto-generated/>
        global using global::System;
        global using global::System.Collections.Generic;
        global using global::System.IO;
        global using global::System.Linq;
        global using global::System.Net.Http;
        global using global::System.Threading;
        global using global::System.Threading.Tasks;
        global using global::Cabazure.Client;
        """;

    public static async Task VerifyEndpoint(params string[] sources)
    {
        var initialCompilation = CompileSources(sources);

        var endpointGenerator = new ClientEndpointGenerator();
        var driver = CSharpGeneratorDriver
            .Create(endpointGenerator)
            .RunGeneratorsAndUpdateCompilation(
                initialCompilation,
                out var finalCompilation,
                out _);

        await Verifier.Verify(driver);

        ThrowOnCompilationErrors(finalCompilation);
    }

    public static async Task VerifyInitialization(params string[] sources)
    {
        var initialCompilation = CompileSources(sources);

        var endpointGenerator = new ClientEndpointGenerator();
        CSharpGeneratorDriver
            .Create(endpointGenerator)
            .RunGeneratorsAndUpdateCompilation(
                initialCompilation,
                out var endpointCompilation,
                out _);

        var initializationGenerator = new ClientInitializationGenerator();
        var driver = CSharpGeneratorDriver
            .Create(initializationGenerator)
            .RunGeneratorsAndUpdateCompilation(
                endpointCompilation,
                out var finalCompilation,
                out _);

        await Verifier.Verify(driver);

        ThrowOnCompilationErrors(finalCompilation);
    }

    public static IEnumerable<DiagnosticDescriptor> GetDiagnostics(params string[] sources)
    {
        var initialCompilation = CompileSources(sources);

        CSharpGeneratorDriver
            .Create(new ClientEndpointGenerator())
            .RunGeneratorsAndUpdateCompilation(
                initialCompilation,
                out var endpointCompilation,
                out var endpointDiagnostics);

        CSharpGeneratorDriver
            .Create(new ClientInitializationGenerator())
            .RunGeneratorsAndUpdateCompilation(
                endpointCompilation,
                out _,
                out var initializationDiagnostics);

        return endpointDiagnostics
            .Union(initializationDiagnostics)
            .Select(d => d.Descriptor);
    }

    private static CSharpCompilation CompileSources(params string[] sources)
    {
        var syntaxTrees = sources
            .Append(GlobalUsings)
            .Select(s => CSharpSyntaxTree.ParseText(s));

        var references = AppDomain.CurrentDomain
            .GetAssemblies()
            .Where(x => !x.IsDynamic && !string.IsNullOrWhiteSpace(x.Location))
            .Append(typeof(ClientRequestOptions).Assembly)
            .Append(typeof(JsonSerializerOptions).Assembly)
            .Append(typeof(IServiceCollection).Assembly)
            .Append(typeof(IHttpClientBuilder).Assembly)
            .Append(typeof(HttpMethod).Assembly)
            .Append(typeof(HttpStatusCode).Assembly)
            .Append(typeof(IServiceProvider).Assembly)
            .Append(typeof(StringValues).Assembly)
            .Append(typeof(OptionsServiceCollectionExtensions).Assembly)
            .Append(typeof(TokenCredential).Assembly)
            .Select(x => MetadataReference.CreateFromFile(x.Location));

        return CSharpCompilation.Create(
            assemblyName: "Tests",
            syntaxTrees,
            references,
            new(OutputKind.DynamicallyLinkedLibrary));
    }

    private static void ThrowOnCompilationErrors(Compilation compilation)
    {
        var errors = compilation
            .GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .Select(d => d.GetMessage())
            .ToArray();

        if (errors.Length > 0)
        {
            throw new ArgumentException(string.Join("\n", errors));
        }
    }
}
